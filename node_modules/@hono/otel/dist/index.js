// src/index.ts
import {
  context as otelContext,
  propagation,
  trace,
  SpanKind,
  SpanStatusCode
} from "@opentelemetry/api";
import {
  ATTR_HTTP_REQUEST_METHOD,
  ATTR_URL_FULL,
  ATTR_HTTP_ROUTE,
  ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_RESPONSE_HEADER,
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION
} from "@opentelemetry/semantic-conventions";
import { createMiddleware } from "hono/factory";
import { routePath } from "hono/route";

// package.json
var package_default = {
  name: "@hono/otel",
  version: "1.0.1",
  description: "OpenTelemetry middleware for Hono",
  type: "module",
  module: "dist/index.js",
  types: "dist/index.d.ts",
  files: [
    "dist"
  ],
  scripts: {
    build: "tsup ./src/index.ts",
    format: "prettier --check . --ignore-path ../../.gitignore",
    lint: "eslint",
    prepack: "yarn build",
    publint: "attw --pack && publint",
    typecheck: "tsc -b tsconfig.json",
    test: "vitest",
    "version:jsr": "yarn version:set $npm_package_version"
  },
  exports: {
    ".": {
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      require: {
        types: "./dist/index.d.cts",
        default: "./dist/index.cjs"
      }
    }
  },
  license: "MIT",
  publishConfig: {
    registry: "https://registry.npmjs.org",
    access: "public"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/honojs/middleware.git",
    directory: "packages/otel"
  },
  homepage: "https://github.com/honojs/middleware",
  peerDependencies: {
    hono: ">=4.0.0"
  },
  dependencies: {
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/semantic-conventions": "^1.28.0"
  },
  devDependencies: {
    "@arethetypeswrong/cli": "^0.18.2",
    "@opentelemetry/core": "^2.2.0",
    "@opentelemetry/sdk-metrics": "^2.2.0",
    "@opentelemetry/sdk-trace-base": "^2.2.0",
    "@opentelemetry/sdk-trace-node": "^2.2.0",
    hono: "^4.10.1",
    publint: "^0.3.14",
    tsup: "^8.5.0",
    typescript: "^5.8.2",
    vitest: "^3.2.4"
  }
};

// src/consts.ts
var INSTRUMENTATION_SCOPE = {
  name: package_default.name,
  version: package_default.version
};

// src/trackers.ts
import { metrics, ValueType } from "@opentelemetry/api";
import {
  METRIC_HTTP_SERVER_ACTIVE_REQUESTS,
  METRIC_HTTP_SERVER_REQUEST_DURATION
} from "@opentelemetry/semantic-conventions/incubating";
var getMeter = (config) => (config.meterProvider ?? metrics.getMeterProvider()).getMeter(INSTRUMENTATION_SCOPE.name);
var createRequestDurationTracker = (config) => {
  const histogram = getMeter(config).createHistogram(METRIC_HTTP_SERVER_REQUEST_DURATION, {
    description: "Duration of HTTP requests in seconds",
    unit: "s",
    valueType: ValueType.DOUBLE
  });
  return {
    record(duration, attrs) {
      histogram.record(duration, attrs);
    }
  };
};
var createActiveRequestsTracker = (config) => {
  const counter = getMeter(config).createUpDownCounter(METRIC_HTTP_SERVER_ACTIVE_REQUESTS, {
    description: "Number of active (in-flight) HTTP server requests",
    valueType: ValueType.INT
  });
  return {
    increment(attrs) {
      counter.add(1, attrs);
    },
    decrement(attrs) {
      counter.add(-1, attrs);
    }
  };
};

// src/index.ts
var normalizeConfig = (config) => {
  const reqHeadersSrc = [...config?.captureRequestHeaders ?? []];
  const resHeadersSrc = [...config?.captureResponseHeaders ?? []];
  const requestHeaderSet = new Set(reqHeadersSrc.map((h) => h.toLowerCase()));
  const responseHeaderSet = new Set(resHeadersSrc.map((h) => h.toLowerCase()));
  const norm = {
    ...config,
    requestHeaderSet,
    responseHeaderSet,
    captureRequestHeaders: reqHeadersSrc,
    captureResponseHeaders: resHeadersSrc
  };
  return norm;
};
var resolveTracer = (config) => {
  if (config.tracer) return config.tracer;
  const provider = config.tracerProvider ?? trace.getTracerProvider();
  return provider.getTracer(INSTRUMENTATION_SCOPE.name, INSTRUMENTATION_SCOPE.version);
};
var httpInstrumentationMiddleware = (userConfig = {
  captureRequestHeaders: [],
  captureResponseHeaders: [],
  disableTracing: false
}) => {
  const config = normalizeConfig(userConfig);
  const tracer = config.disableTracing ? void 0 : resolveTracer(config);
  const spanName = (c) => config.spanNameFactory?.(c) ?? `${c.req.method} ${routePath(c)}`;
  const activeReqs = createActiveRequestsTracker(config);
  const requestDuration = createRequestDurationTracker(config);
  return createMiddleware(async (c, next) => {
    const parent = propagation.extract(otelContext.active(), c.req.header());
    const method = c.req.method;
    const stableAttrs = {
      [ATTR_HTTP_REQUEST_METHOD]: method,
      [ATTR_SERVICE_NAME]: config.serviceName,
      [ATTR_SERVICE_VERSION]: config.serviceVersion
    };
    activeReqs.increment(stableAttrs);
    const monotonicStartTime = performance.now();
    const deferredRequestHeaderAttributes = {};
    const reqHeaders = c.req.header();
    for (const [rawName, value] of Object.entries(reqHeaders)) {
      const name = rawName.toLowerCase();
      if (config.requestHeaderSet.has(name)) {
        deferredRequestHeaderAttributes[ATTR_HTTP_REQUEST_HEADER(name)] = value;
      }
    }
    const finalize = (span, error) => {
      try {
        const status = c.res.status;
        if (span) {
          const captureResp = config.responseHeaderSet;
          for (const [name, value] of c.res.headers.entries()) {
            const lower = name.toLowerCase();
            if (captureResp.has(lower)) {
              span.setAttribute(ATTR_HTTP_RESPONSE_HEADER(lower), value);
            }
          }
          span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, status);
          if (status >= 500) {
            span.setStatus({ code: SpanStatusCode.ERROR });
          }
          if (error) {
            try {
              span.recordException(error);
            } catch {
            }
            span.setStatus({ code: SpanStatusCode.ERROR });
          }
        }
      } finally {
        activeReqs.decrement(stableAttrs);
        span?.setAttribute(ATTR_HTTP_ROUTE, routePath(c));
        span?.updateName(spanName(c));
        requestDuration.record(performance.now() - monotonicStartTime, {
          ...stableAttrs,
          [ATTR_HTTP_ROUTE]: routePath(c),
          [ATTR_HTTP_RESPONSE_STATUS_CODE]: c.res.status
        });
      }
    };
    if (!tracer) {
      try {
        await next();
        finalize(void 0, void 0);
      } catch (e) {
        finalize(void 0, e);
        throw e;
      }
      return;
    }
    return tracer.startActiveSpan(
      spanName(c),
      {
        kind: SpanKind.SERVER,
        startTime: config.getTime?.(),
        attributes: {
          ...stableAttrs,
          [ATTR_URL_FULL]: c.req.url,
          [ATTR_HTTP_ROUTE]: routePath(c)
        }
      },
      parent,
      async (span) => {
        try {
          for (const [k, v] of Object.entries(deferredRequestHeaderAttributes)) {
            span.setAttribute(k, v);
          }
          await next();
          finalize(span, c.error);
        } catch (e) {
          finalize(span, e);
          throw e;
        } finally {
          span.end(config.getTime?.());
        }
      }
    );
  });
};
export {
  httpInstrumentationMiddleware
};
